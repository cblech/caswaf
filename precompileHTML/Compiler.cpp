#include "Compiler.h"
#include <fstream>
#include <boost/algorithm/string.hpp>
#include "log.h"

using namespace std;


Compiler::Compiler(path htmlPath, path generatedPath):
	htmlPath(htmlPath),
	generatedPath(generatedPath)
{
	compilePath(htmlPath);

	ofstream ofs((generatedPath/"html.generated.h").string());

	ofs << "// Generated by precompileHTML" << endl;
	ofs << "//" << endl;
	ofs << "//" << endl;
	ofs << "// #####################" << endl;
	ofs << "// ##  DO NOT MODIFY  ##" << endl;
	ofs << "// #####################" << endl;
	ofs << "//" << endl;

	for (path p : allGenerated) 
	{
	ofs << "#include \""<< p.lexically_relative(generatedPath).string() <<"\""<< endl;
	}


	ofs.close();
}

bool Compiler::compilePath(fs::path p)
{
	try {

		if (fs::is_regular_file(p)) {
			if (p.extension() == ".html") {
				
				if (!compileFile(p))
					return false;
			}
		}
		else {
			fs::directory_iterator end_itr;

			// cycle through the directory
			for (fs::directory_iterator itr(p); itr != end_itr; ++itr)
			{
				if (!compilePath(itr->path()))
					return false;
			}
		}
	}
	catch (std::exception & e) {
		error << "an error ocured: " << e.what();
		return false;
	}
	catch (...) {
		error << "an error ocured";
		return false;
	}
	return true;
}

bool Compiler::compileFile(fs::path sourcePath)
{
	//define the Path for the .html.h file (Target)
	path destPath = (generatedPath / sourcePath.lexically_relative(htmlPath)).string() + ".h";

	//create the target directory if not exist
	if (!fs::is_directory(destPath.parent_path()))
	{
		fs::create_directories(destPath.parent_path());
	}

	//debug
	info << "Compiling: " << sourcePath << " into " << destPath;

	//input stream of the .html file (source)
	ifstream ifs(sourcePath.string());

	//list of all tokens of the .html file
	list<htmlToken> tokens;

	//Tokenizing
	string line;
	while (getline(ifs, line))
	{
		boost::trim(line);


		if (line.size() > 0 && line.at(0) == '@')
		{
			tokens.push_back(htmlToken(htmlTokenType::part, line));
		}
		else
		{
			tokens.push_back(htmlToken(htmlTokenType::html, line));
		}
	}
	ifs.close();


	//open .html.h stream (writing stream)
	ofstream ofs(destPath.string());

	//add notes to file
	ofs << "// Generated by precompileHTML"<<endl;
	ofs << "//"<<endl;
	ofs << "//"<<endl;
	ofs << "// #####################"<<endl;
	ofs << "// ##  DO NOT MODIFY  ##"<<endl;
	ofs << "// #####################"<<endl;
	ofs << "//" << endl;


	ofs << "" << endl;


	htmlTokenType lastType = none;
	for (htmlToken token : tokens)
	{
		switch (token.type)
		{
		case html:

			break;
		case part:

			break;
		default:
			break;
		}

		lastType = token.type;
	}



	ofs.close();

	allGenerated.push_back(destPath);
	return true;
}
