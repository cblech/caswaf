#include "Compiler.h"
#include <fstream>
#include <boost/algorithm/string.hpp>
#include "log.h"
#include <sstream>

using namespace std;

inline std::string strToIntList(std::string s)
{
	stringstream retVal;
	retVal << "{";
	bool first = true;

	for (char c : s)
	{
		if (!first)
			retVal << ",";
		else
			first = false;

		retVal << (int)c;
		
	}

	retVal << "}";
	return retVal.str();
}


Compiler::Compiler(path htmlPath, path generatedPath) :
	htmlPath(htmlPath),
	generatedPath(generatedPath)
{

	system("echo %cd%");
	compilePath(htmlPath / "html");
	compileStatic(htmlPath / "static");

	ofstream ofs((generatedPath / "html.generated.h").string());

	ofs << "// Generated by precompileHTML" << endl;
	ofs << "//" << endl;
	ofs << "//" << endl;
	ofs << "// #####################" << endl;
	ofs << "// ##  DO NOT MODIFY  ##" << endl;
	ofs << "// #####################" << endl;
	ofs << "//" << endl;

	for (path p : allGenerated)
	{
		ofs << "#include \"" << p.lexically_relative(generatedPath).string() << "\"" << endl;
	}


	ofs.close();
}

bool Compiler::compilePath(fs::path p)
{
	try {

		if (fs::is_regular_file(p)) {
			if (p.extension() == ".html") {

				if (!compileFile(p))
					return false;
			}
		}
		else {
			fs::directory_iterator end_itr;

			// cycle through the directory
			for (fs::directory_iterator itr(p); itr != end_itr; ++itr)
			{
				if (!compilePath(itr->path()))
					return false;
			}
		}
	}
	catch (std::exception & e) {
		error << "an error ocured: " << e.what();
		return false;
	}
	catch (...) {
		error << "an error ocured";
		return false;
	}
	return true;
}

bool Compiler::compileStatic(path p)
{
	try {

		//open StaticRecouces.h stream (writing stream)
		ofstream ofs((generatedPath / "StaticRecouces.h").string());

		//add notes to file
		ofs << "#pragma once" << endl;
		ofs << "// Generated by precompileHTML" << endl;
		ofs << "//" << endl;
		ofs << "//" << endl;
		ofs << "// #####################" << endl;
		ofs << "// ##  DO NOT MODIFY  ##" << endl;
		ofs << "// #####################" << endl;
		ofs << "//" << endl;
		ofs << "#include \"../web-server/StaticRecource.h\"" << endl;


		ofs << endl;


		ofs << "namespace StaticResources {" << endl;

		ofs << compileStaticFile(p);

		ofs << "}" << endl;
	}
	catch (std::exception & e) {
		error << "an error ocured: " << e.what();
		return false;
	}
	catch (...) {
		error << "an error ocured";
		return false;
	}

	return true;
}

constexpr unsigned int str2int(const char* str, int h = 0)
{
	return !str[h] ? 5381 : (str2int(str, h + 1) * 33) ^ str[h];
}

std::string Compiler::compileStaticFile(path p)
{

	if (fs::is_regular_file(p)) {


		stringstream ss;
		stringstream ssSymbol;

		ss << "//" << p.filename().string() << endl;

		ifstream ifs(p.string(), ios::binary);

		ss << "const char ";
		for (char c : p.filename().string())
		{
			if (c == '.')
			{
				ssSymbol << "_";
			}
			else
			{
				ssSymbol << c;
			}
		}
		ss << ssSymbol.str() << "_data[]  = { ";

		bool isfirst = true;
		char c = ifs.get();
		int counter = 0;
		while (!ifs.eof())
		{
			ss << ((isfirst) ? "" : ",") << "0x" << std::hex << (int)c<< std::dec;
			c = ifs.get();
			isfirst = false;
			counter++;
		}

		ss << " };" << endl;

		ss << "Resource " << ssSymbol.str() << "{ " << counter << ", " << ssSymbol.str() << "_data, \"";

		switch (str2int(p.extension().string().c_str()))
		{
		case str2int(".JPEG"):
		case str2int(".JPG"):
		case str2int(".jpeg"):
		case str2int(".jpg"):
			ss << "image/jpg";
			break;
		case str2int(".PNG"):
		case str2int(".png"):
			ss << "image/png";
			break;
		case str2int(".css"):
			ss << "text/css";
			break;
		default:
			warning << "Static Compiler: "<< p.filename().string() <<" Unknown File extention. Defaulting to text/plain";
			ss << "text/plain";
			break;
		}

		ss << "\" };" << endl;

		return ss.str();


	}
	else {
		fs::directory_iterator end_itr;

		stringstream ss;

		// cycle through the directory
		for (fs::directory_iterator itr(p); itr != end_itr; ++itr)
		{
			ss << compileStaticFile(*itr);
		}

		return ss.str();
	}

	return "";
}

bool Compiler::compileFile(fs::path sourcePath)
{
	//define the Path for the .html.h file (Target)
	path destPath = (generatedPath / sourcePath.lexically_relative(htmlPath)).string() + ".h";

	//extract the Tecnical Partname
	std::string partName = destPath.filename().string().substr(0, destPath.filename().string().size()-7);

	//plugin Points
	std::map<std::string, int> pluginPoints;

	//create the target directory if not exist
	if (!fs::is_directory(destPath.parent_path()))
	{
		fs::create_directories(destPath.parent_path());
	}
	
	//debug
	info << "Compiling: " << sourcePath << " into " << destPath;

	//input stream of the .html file (source)
	ifstream ifs(sourcePath.string());

	//list of all tokens of the .html file
	list<htmlToken> tokens;

	//Tokenizing
	string line;
	int pluginCount = 0;
	while (getline(ifs, line))
	{
		boost::trim(line);

		
		if (line.size() > 0 && line.at(0) == '@')
		{
			tokens.push_back(htmlToken(htmlTokenType::part, line.substr(1)));
			pluginPoints.try_emplace(line.substr(1), ++pluginCount);
		}
		else
		{
			tokens.push_back(htmlToken(htmlTokenType::html, line));
		}
	}
	ifs.close();


	//optimize Tokens
	/*
	std::list<htmlToken>::iterator aktToken=tokens.begin(),nxtToken; 
	while(aktToken!=tokens.end())
	{
		nxtToken = aktToken;
		nxtToken++;

		if (aktToken->type == html && nxtToken->type == html)
		{
			//TODO Bring two html tokens together
		}

		aktToken++;
	}
*/

	//open .html.h stream (writing stream)
	ofstream ofs(destPath.string());

	//add notes to file
	ofs << "// Generated by precompileHTML" << endl;
	ofs << "//" << endl;
	ofs << "//" << endl;
	ofs << "// #####################" << endl;
	ofs << "// ##  DO NOT MODIFY  ##" << endl;
	ofs << "// #####################" << endl;
	ofs << "//" << endl;


	ofs << endl;


	ofs << "#pragma once\n#include \"../web-server/Part.h\"\n\nclass Part" << partName<<" :public Part\n{\npublic:\n";

	for (auto pp : pluginPoints)
	{
		ofs << "static const int " << pp.first << " = " << pp.second << ";" << endl;
	}

	ofs << "Part" << partName << "()\n{\n";

	for (htmlToken token : tokens)
	{
		ofs << "tokenList.push_back({ ";

		switch (token.type)
		{
		case html:

			ofs <<  strToIntList(token.text) <<",Token::Type::html,0";

			break;
		case part:

			ofs << "\"" << token.text << "\",Token::Type::html,"<< pluginPoints.at(token.text);

			break;
		default:
			ofs << "\"\",Token::Type::html,0";
			break;
		}

		ofs << " });"<<endl;
		
	}

	ofs << "}\n};\n";

	ofs.close();

	allGenerated.push_back(destPath);
	return true;
}
