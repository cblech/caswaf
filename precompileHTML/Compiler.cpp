#include "Compiler.h"
#include <fstream>
#include <boost/algorithm/string.hpp>
#include "log.h"
#include <sstream>
#include <map>
#include "HTMLParser.h"

using namespace std;

inline std::string strToIntList(std::string s)
{
	stringstream retVal;
	retVal << "{";
	bool first = true;

	for (char c : s)
	{
		if (!first)
			retVal << ",";
		else
			first = false;

		retVal << (int)c;

	}

	retVal << "}";
	return retVal.str();
}


Compiler::Compiler(path htmlPath, path generatedPath) :
	htmlPath(htmlPath),
	generatedPath(generatedPath)
{

	system("echo %cd%");
	compilePath(htmlPath / "html");
	compileStatic(htmlPath / "static");

	ofstream ofs((generatedPath / "html.generated.h").string());

	ofs << "// Generated by precompileHTML" << endl;
	ofs << "//" << endl;
	ofs << "//" << endl;
	ofs << "// #####################" << endl;
	ofs << "// ##  DO NOT MODIFY  ##" << endl;
	ofs << "// #####################" << endl;
	ofs << "//" << endl;

	for (path p : allGenerated)
	{
		
		ofs << "#include \"" << p.lexically_relative(generatedPath).string() << "\"" << endl;
	}


	ofs.close();
}

bool Compiler::compilePath(fs::path p)
{
	try {

		if (fs::is_regular_file(p)) {
			if (p.extension() == ".html") {

				if (!compileFile(p))
					return false;
			}
		}
		else {
			fs::directory_iterator end_itr;

			// cycle through the directory
			for (fs::directory_iterator itr(p); itr != end_itr; ++itr)
			{
				if (!compilePath(itr->path()))
					return false;
			}
		}
	}
	catch (std::exception & e) {
		error << "an error ocured: " << e.what();
		return false;
	}
	catch (...) {
		error << "an error ocured";
		return false;
	}
	return true;
}


bool Compiler::compileStatic(path p)
{
	try {

		//open StaticRecouces.h stream (writing stream)
		ofstream ofs((generatedPath / "StaticRecouces.h").string());

		//add notes to file
		ofs << "#pragma once" << endl;
		ofs << "// Generated by precompileHTML" << endl;
		ofs << "//" << endl;
		ofs << "//" << endl;
		ofs << "// #####################" << endl;
		ofs << "// ##  DO NOT MODIFY  ##" << endl;
		ofs << "// #####################" << endl;
		ofs << "//" << endl;
		ofs << "#include \"../web-server/StaticRecource.h\"" << endl;


		ofs << endl;


		ofs << "namespace StaticResources {" << endl;

		ofs << compileStaticFile(p);

		ofs << "}" << endl;
	}
	catch (std::exception & e) {
		error << "an error ocured: " << e.what();
		return false;
	}
	catch (...) {
		error << "an error ocured";
		return false;
	}

	return true;
}

constexpr unsigned int str2int(const char* str, int h = 0)
{
	return !str[h] ? 5381 : (str2int(str, h + 1) * 33) ^ str[h];
}

std::string Compiler::compileStaticFile(path p)
{

	if (fs::is_regular_file(p)) {


		stringstream ss;
		stringstream ssSymbol;

		ss << "//" << p.filename().string() << endl;

		ifstream ifs(p.string(), ios::binary);

		ss << "const char ";
		for (char c : p.filename().string())
		{
			if (c == '.')
			{
				ssSymbol << "_";
			}
			else
			{
				ssSymbol << c;
			}
		}
		ss << ssSymbol.str() << "_data[]  = { ";

		bool isfirst = true;
		char c = ifs.get();
		int counter = 0;
		while (!ifs.eof())
		{
			ss << ((isfirst) ? "" : ",") << "0x" << std::hex << (int)c << std::dec;
			c = ifs.get();
			isfirst = false;
			counter++;
		}

		ss << " };" << endl;

		ss << "Resource " << ssSymbol.str() << "{ " << counter << ", " << ssSymbol.str() << "_data, \"";

		switch (str2int(p.extension().string().c_str()))
		{
		case str2int(".JPEG"):
		case str2int(".JPG"):
		case str2int(".jpeg"):
		case str2int(".jpg"):
			ss << "image/jpg";
			break;
		case str2int(".PNG"):
		case str2int(".png"):
			ss << "image/png";
			break;
		case str2int(".css"):
			ss << "text/css";
			break;
		default:
			warning << "Static Compiler: " << p.filename().string() << " Unknown File extention. Defaulting to text/plain";
			ss << "text/plain";
			break;
		}

		ss << "\" };" << endl;

		return ss.str();


	}
	else {
		fs::directory_iterator end_itr;

		stringstream ss;

		// cycle through the directory
		for (fs::directory_iterator itr(p); itr != end_itr; ++itr)
		{
			ss << compileStaticFile(*itr);
		}

		return ss.str();
	}

	return "";
}

void Compiler::htmlNodesToHtmlToken(const HTMLNodeList & nodes, list<htmlToken>& tokens, string& tokenWrite, std::map<std::string, int> &  pluginPoints, int & pluginCount, std::map<std::string,int>& dataPoints , int & dataCount )
{

	for (auto node : nodes)
	{
		//Handle Part Tags
		if (node.getTagName() == "part")
		{
			tokenWrite += node.getOpeningTag();

			if (node.hasAttribute("id"))
			{
				tokens.push_back(htmlToken{ htmlTokenType::html,tokenWrite });
				tokenWrite = "";


				tokens.push_back(htmlToken{ htmlTokenType::part,node.getAttribute("id") });
				pluginPoints.try_emplace(node.getAttribute("id"), ++pluginCount);
			}
			else
			{
				warning << "Part Tag has no id. Ignoring.";
			}

			tokenWrite += node.getClosingTag();

		}
		//Handle Data Tags
		else if (node.getTagName() == "data")
		{
			tokenWrite += node.getOpeningTag();

			if (node.hasAttribute("id"))
			{
				tokens.push_back(htmlToken{ htmlTokenType::html,tokenWrite });
				tokenWrite = "";


				tokens.push_back(htmlToken{ htmlTokenType::data,node.getAttribute("id") });
				dataPoints.try_emplace(node.getAttribute("id"), ++dataCount);
			}
			else
			{
				warning << "Data Tag has no id. Ignoring.";
			}

			tokenWrite += node.getClosingTag();
		}
		//Handle Text Nodes
		else if (node.isTextNode())
		{
			tokenWrite += node.getText();
		}
		//Handle Empty nodes
		else if (node.isEmpty())
		{
			tokenWrite += node.getOpeningTag();
		}
		//Handle All Other Tags
		else
		{
			tokenWrite += node.getOpeningTag();
			htmlNodesToHtmlToken(node.getChildrenIncludingText(), tokens, tokenWrite,pluginPoints,pluginCount, dataPoints,dataCount );
			tokenWrite += node.getClosingTag();
		}
	}



}


bool Compiler::compileFile(fs::path sourcePath)
{
	//define the Path for the .html.h file (Target)
	path destPath = (generatedPath / sourcePath.lexically_relative(htmlPath)).string() + ".h";

	//extract the Tecnical Partname
	std::string partName = destPath.filename().string().substr(0, destPath.filename().string().size() - 7);



	//create the target directory if not exist
	if (!fs::is_directory(destPath.parent_path()))
	{
		fs::create_directories(destPath.parent_path());
	}

	//debug
	info << "Compiling: " << sourcePath << " into " << destPath;

	//input stream of the .html file (source)
	ifstream ifs(sourcePath.string());

	//read .html file into string
	ifs.peek();
	string htmlString = "";
	while (!ifs.eof())
	{
		htmlString += ifs.get();
		ifs.peek();
	}

	//close the .html file
	ifs.close();


	HTMLNodeList HTMLPart = HTMLParser::parseHTML(htmlString);


	//list of all tokens of the .html file
	list<htmlToken> tokens;

	//Temporary variable for tokenizing
	string tokenWrite = "";

	//plugin Points
	std::map<std::string, int> pluginPoints;
	int pluginCount = 0;

	//data Points
	std::map<std::string, int> dataPoints;
	int dataCount = 0;

	//Tokenize
	htmlNodesToHtmlToken(HTMLPart,tokens,tokenWrite,pluginPoints,pluginCount, dataPoints,dataCount );

	//create last Token
	tokens.push_back(htmlToken{ htmlTokenType::html,tokenWrite });


	//open .html.h stream (writing stream)
	ofstream ofs(destPath.string());

	//add notes to file
	ofs << "// Generated by precompileHTML" << endl;
	ofs << "//" << endl;
	ofs << "//" << endl;
	ofs << "// #####################" << endl;
	ofs << "// ##  DO NOT MODIFY  ##" << endl;
	ofs << "// #####################" << endl;
	ofs << "//" << endl;


	ofs << endl;


	ofs << "#pragma once\n#include \"../web-server/Part.h\"\n\nclass Part" << partName << " :public Part\n{\npublic:\n";

	for (auto pp : pluginPoints)
	{
		ofs << "static const int " << pp.first << " = " << pp.second << ";" << endl;
	}	
	for (auto dp : dataPoints)
	{
		ofs << "static const int " << dp.first << " = " << dp.second << ";" << endl;
	}

	ofs << "Part" << partName << "()\n{\n";

	for (htmlToken token : tokens)
	{
		ofs << "tokenList.push_back({ ";

		switch (token.type)
		{
		case  htmlTokenType::html:

			ofs << strToIntList(token.text) << ",Token::Type::html,0";

			break;
		case  htmlTokenType::part:

			ofs << strToIntList(token.text) << ",Token::Type::part," << pluginPoints.at(token.text);

			break;
		case htmlTokenType::data:

			ofs << strToIntList(token.text) << ",Token::Type::data," << dataPoints.at(token.text);

			break;
		default:
			ofs << "\"\",Token::Type::html,0";
			break;
		}

		ofs << " });" << endl;

	}

	ofs << "}\n};\n";

	ofs.close();

	allGenerated.push_back(destPath);
	return true;
}
